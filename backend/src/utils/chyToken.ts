// chy-auth-cipheryToken.ts
// Chy Auth: CipherToken
// Lightweight symmetric token with integrity and confidentiality guarantees
// References used: [7†L208-L215] JWT exposure issues, [8†L94-L102] PoP concept, [10†L45-L49] timingSafeEqual

import crypto from 'crypto';

const PREFIX = 'CSTv1';

export interface TokenPayload {
    userId: string | number;
    acl: 'read-only' | 'read-write' | string;
    pubKey: string;
    issuedAt: number;
    [key: string]: any;
}

export class CipherToken {
    private ENC_KEY: Buffer;
    private KEY_ID = '1';

    constructor(encKeyHex: string) {
        // Accepts a 64-char hex string to form a 32-byte AES key
        this.ENC_KEY = Buffer.from(encKeyHex, 'hex');
    }

    /**
     * Encrypts a payload using AES-256-GCM.
     * AES-GCM provides confidentiality + authentication (tag-based integrity).
     * Output format: version.keyId.iv.ciphertext.tag
     */
    encrypt = (payload: TokenPayload): string => {
        const iv = crypto.randomBytes(12); // Recommended IV size for GCM
        const cipher = crypto.createCipheriv('aes-256-gcm', this.ENC_KEY, iv);

        const json = JSON.stringify(payload);
        const ciphertext = Buffer.concat([
            cipher.update(json, 'utf8'),
            cipher.final()
        ]);
        const tag = cipher.getAuthTag();

        return [
            PREFIX,
            this.KEY_ID,
            iv.toString('base64'),
            ciphertext.toString('base64'),
            tag.toString('base64')
        ].join('.');
    };

    /**
     * Decrypts a token generated by this class.
     * Validates structure and integrity tag before decoding.
     */
    decrypt = (token: string): TokenPayload => {
        const parts = token.split('.');
        if (parts.length !== 5 || parts[0] !== PREFIX || parts[1] !== this.KEY_ID) {
            throw new Error('Invalid token format or prefix');
        }
        const [_, __, ivB64, ciphertextB64, tagB64] = parts;
        const iv = Buffer.from(ivB64, 'base64');
        const ciphertext = Buffer.from(ciphertextB64, 'base64');
        const tag = Buffer.from(tagB64, 'base64');

        const decipher = crypto.createDecipheriv('aes-256-gcm', this.ENC_KEY, iv);
        decipher.setAuthTag(tag);

        const decrypted = Buffer.concat([
            decipher.update(ciphertext),
            decipher.final()
        ]);

        return JSON.parse(decrypted.toString('utf8'));
    };

    /**
     * Timing-safe buffer comparison (constant time to avoid timing attacks).
     */
    static timingSafeCompare = (a: Buffer, b: Buffer): boolean => {
        if (a.length !== b.length) return false;
        return crypto.timingSafeEqual(a, b);
    };

    /**
     * Generates a public/private key pair for use with token signature (PoP).
     * Public key is exported as base64 DER (SPKI) for embedding in payloads.
     */
    static generateKeyPair = (): { publicKey: string; privateKey: crypto.KeyObject } => {
        const { publicKey, privateKey } = crypto.generateKeyPairSync('ed25519');
        const pubDer = publicKey.export({ format: 'der', type: 'spki' }).toString('base64');
        return { publicKey: pubDer, privateKey };
    };
}